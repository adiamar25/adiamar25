// This file is part of nand2tetris, as taught in The Hebrew University, and
// was written by Aviv Yaish. It is an extension to the specifications given
// [here](https://www.nand2tetris.org) (Shimon Schocken and Noam Nisan, 2017),
// as allowed by the Creative Common Attribution-NonCommercial-ShareAlike 3.0
// Unported [License](https://creativecommons.org/licenses/by-nc-sa/3.0/).

// This chip is an extension of the regular CPU that uses the extended ALU.
// If instruction[15]==0 or (instruction[14]==1 and instruction[13]==1),
// then CpuMul behaves exactly the same as the regular CPU.
// If instruction[15]==1 and instruction[14]==0 the chip will behave as follows:
// | Instruction           | 15 | 14 | 13 | a | c1 | c2 | c3 | c4 | c5 | c6 |
// |-----------------------|:--:|:--:|:--:|:-:|:--:|:--:|:--:|:--:|:--:|:--:|
// | Regular a-instruction |  0 |  * |  * | * |  * |  * |  * |  * |  * |  * |
// | Regular c-instruction |  1 |  1 |  1 | * |  * |  * |  * |  * |  * |  * |
// | dest=A<<;jump         |  1 |  0 |  1 | 0 |  1 |  0 |  0 |  0 |  0 |  0 |
// | dest=D<<;jump         |  1 |  0 |  1 | 0 |  1 |  1 |  0 |  0 |  0 |  0 |
// | dest=M<<;jump         |  1 |  0 |  1 | 1 |  1 |  0 |  0 |  0 |  0 |  0 |
// | dest=A>>;jump         |  1 |  0 |  1 | 0 |  0 |  0 |  0 |  0 |  0 |  0 |
// | dest=D>>;jump         |  1 |  0 |  1 | 0 |  0 |  1 |  0 |  0 |  0 |  0 |
// | dest=M>>;jump         |  1 |  0 |  1 | 1 |  0 |  0 |  0 |  0 |  0 |  0 |
// Where:
// - "<<" is a left shift, and ">>" is a right shift, as defined in project 2.
//   These notations were chosen because they are used in real programming
//   languages.
// - dest and jump can take the same values as in the regular CPU.

CHIP CpuMul {
    IN  
        inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset=1) or continue executing
                         // the current program (reset=0).
    OUT 
        outM[16],        // M value output
        writeM,          // Write into M? 
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction
    
    PARTS:  
    And(a=instruction[14], b=instruction[13], out=inst13and14);
    Mux(a=true, b=instruction[13], sel=instruction[15], out=inst7);
    Not(in=instruction[15], out=notOP);
    Or(a=inst13and14, b=notOP, out=inst8);
    Or(a=notOP, b=instruction[5], out=Aload); 
    Mux16(a=extendALUout, b=instruction, sel=notOP, out=mux1out);
    ARegister(in=mux1out, load=Aload, out=Aout, out[0..14]=addressM);
    And(a=instruction[15], b=instruction[12], out=amSwitch);
    // mux with the appropriate sel bit, instruction[12].
    Mux16(a=Aout, b=inM, sel=amSwitch, out=mux2out); 
    And(a=instruction[15], b=instruction[4], out=Dload);    
    // we feed the D-register only if it's C-instruction *and* if 
    // the relevant load bit, instruction[4]==1
    DRegister(in=extendALUout, load=Dload, out=Dout);
    // the instruction bits which inputs to the alu 
    // through C-instruction
    // are the instruction[6..11] bits. 
    // those bits goes into the 0..5 indexes
    // of the instruction's input of the ExtendAlu Chip. 
    // the bit instruction[6] of the ExtendAlu Chip is 
    // actually useless, therefore
    // it doesn't matter what we input there.
    ExtendAlu(x=Dout, y=mux2out, 
            instruction[8]= inst8, 
            instruction[7]=inst7, 
            instruction[6]=true, 
            instruction[0..5]=instruction[6..11], 
            out=extendALUout, out=outM, zr=zrout, ng=ngout); 
    
    And(a=instruction[3], b=instruction[15], out=writeM); 
    // instruction[3] is the relevant load bit of writeM,
    // so if instruction[3]==1 *and* instruction[15]==1 (which means
    // it's C-instruction), then writeM==1.
    
    Or(a=ngout, b=zrout, out=notpositive);
    Not(in=notpositive, out=positive);
    And(a=ngout, b=instruction[2], out=jlt);
    And(a=zrout, b=instruction[1], out=jeq);
    And(a=positive, b=instruction[0], out=jgt);
    Or(a=jeq, b=jlt, out=jle);
    Or(a=jgt, b=jle, out=jumptoA);
    And(a=instruction[15], b=jumptoA, out=g);
    PC(in=Aout, load=g, inc=true, reset=reset, out[0..14]=pc);
}